# v0.4.0 Design: DSL Extensions & Debugging

## 1. DSL Extensions (Control Flow)

This section defines the new DSL syntax for loops and conditionals, prioritizing simplicity, clarity, and flow consistency.

### 1.1 Core Philosophy
- **Readability**: The meaning should be obvious at a glance.
- **Flow Consistency**: Maintain the left-to-right `>>` flow.
- **Symbolic Roles**:
    - `()`: Grouping
    - `[]`: Iteration (Count / For-each)
    - `%`: Conditional Loop (Until)
    - `switch()[...]`: Conditional Branching

### 1.2 Loop Extensions

#### 1.2.1 Interval Loop (Fixed Count)
```python
(B >> C)[3]
```
- Repeats the subflow `B >> C` 3 times.
- Expands to: `B >> C >> B >> C >> B >> C`
- Count **must be an `int` literal or an expression that resolves to an `int` during flow compilation**. Negative values raise at compile time, `0` is a no-op.
- A `LoopContext` object is pushed to `$ctx.loop` providing `index` (0-based), `iteration`, and `count`.
- Subflow outputs from the previous iteration are discarded unless the user writes them to `$ctx` explicitly; each iteration starts with the same inbound context.

#### 1.2.2 For-Each Loop
```python
(B >> C)["$ctx.items"]
```
- Iterates over the list at `$ctx.items`.
- Executes `B >> C` for each element.
- The iterable expression must resolve to a list/tuple; non-iterables raise during the dry-run check.
- **Loop Item Exposure**
    - `$ctx.loop.item` references the current value.
    - `$ctx.loop.index` gives the 0-based position.
    - `$ctx.loop.path` contains a dot-delimited string (e.g., `items[3]`) for nested loops.
    - The item is also optionally re-bound to a user alias: `(B >> C)["$ctx.items as item"]` binds `$ctx.item`.
- **Alias Grammar**
    - `"$ctx.items as item"` → expression + `as` keyword + identifier.
    - Alias must be a valid Python identifier and cannot shadow an existing context key; duplicates raise during the dry run.
- Loop iterations execute sequentially only. Passing `parallel=...` or similar keyword raises `NotImplementedError` in v0.4.0 so users know concurrency is out of scope for this release.

#### 1.2.3 Conditional Loop (Until)
```python
(B >> C) % "$ctx.metrics.acc > 0.9"
```
- Repeats `B >> C` until the condition evaluates to True.
- **Evaluation order**: execute the subflow once, then evaluate the expression; repeat while the expression returns `False`. (Do-while semantics with an "until True" condition.)
- `UntilNode` accepts optional `max_iter` (default 1000) to prevent infinite loops. Exceeding the limit raises `UntilMaxIterationsExceeded`.
- Loop context mirrors 1.2.1 with `$ctx.loop.iteration` (1-based) and `$ctx.loop.condition` (last evaluated result).
- Expressions use the reference rules in §1.4; failures to evaluate abort the loop with a rich error message containing the offending expression and captured locals.

#### 1.2.4 General Loop Semantics
- `RepeatNode`, `ForEachNode`, and `UntilNode` all share a runtime helper that:
    - Pushes/pops `$ctx.loop`.
    - Resets task-level caches each iteration.
    - Emits structured trace events (`loop.start`, `loop.iteration`, `loop.end`) for observability.
- Nested loops append to `$ctx.loop.path` (e.g., `outer[0].inner[4]`).
- **LoopContext Structure**
    - `name`: auto-generated loop label (e.g., `repeat`, `foreach:items`).
    - `type`: `"repeat" | "foreach" | "until"`.
    - `index`: zero-based counter (not set for until until at least one iteration executes).
    - `iteration`: one-based counter (None before the first run).
    - `count`: expected iterations for repeat (None otherwise).
    - `item`: only populated for for-each.
    - `condition`: last boolean result for until loops.
    - `path`: dotted representation of nested loop ancestry.
    - Exposed under `$ctx.loop` (current) and `$ctx.loops` (stack copy) for inspection/logging.

### 1.3 Conditional Branching (Switch)

#### 1.3.1 Syntax
```python
switch("$ctx.status")[
    "X" >> B,
    "Y" >> C,
    "*" >> D, # Default
]
```

#### 1.3.2 Behavior
- Evaluates `$ctx.status`.
- Matches against keys `"X"`, `"Y"`.
- Executes the corresponding task/flow.
- If no match, executes `*` (default) if present, otherwise proceeds to next node.
- Expression is evaluated once; results are compared using Python equality.
- Case labels support strings, numbers, and booleans; any other type must implement `__str__`.
- Duplicate keys raise at compile/dry-run time.
- The default `*` case is optional but recommended; absence results in a `SwitchNoMatch` warning event when no branch matches.
- **Fallthrough Rules**
    - Only the first matching case executes; there is no fallthrough chaining.
    - Each branch forms an isolated subflow; context mutations do not bleed across other cases unless persisted to `$ctx`.
- **Default Case Semantics**
    - `*` is stored internally as `CaseNode(value="__default__")`.
    - Multiple defaults are rejected.

### 1.4 Value Reference Rules
- Always use `$ctx.xxx` or `$env.xxx`.
- No arbitrary `eval`. Simple parsing or safe evaluation.
- Expressions support:
    - Attribute access via dot (`$ctx.metrics.acc`).
    - Simple comparisons (`>`, `<`, `==`, `!=`, `in`).
    - Boolean ops (`and`, `or`, `not`).
    - Numeric literals and string literals (single/double quotes).
- Functions are **not** callable within expressions.
- Expressions are compiled once, cached, and reused to avoid repeated parsing.
- **Error Messaging**
    - When evaluation fails, raise `ExpressionEvaluationError` referencing the original string, exception type, and snippet of context/environment used.
    - Errors originating from inside loops include the loop path to aid debugging.

### 1.5 Implementation Requirements
- **AST Nodes**: `RepeatNode`, `ForEachNode`, `UntilNode`, `SwitchNode`, `CaseNode`.
- **Operator Overloading**:
    - `__rshift__` (`>>`)
    - `__getitem__` (`[]`)
    - `__mod__` (`%`)
- **Switch Implementation**: `switch(expr)` returns a builder that implements `__getitem__` to accept a tuple of cases.

---

### 1.6 Technical Implementation Details
- **String >> Task**: To support `"X" >> B`, the `Task` (and `Flow`) class must implement `__rrshift__`.
    - When Python sees `"X" >> B`, it tries `str.__rshift__`. Since that fails, it tries `B.__rrshift__("X")`.
    - We will implement `__rrshift__` to return a `CaseNode(value="X", target=B)`.
- **Validation**: `CaseNode` validates that `value` is hashable and `target` is a Task/Flow; otherwise raises `InvalidCaseDefinition`.
- **Grouping**: Parentheses `()` always produce a `SubFlowNode` so chained operators treat `(A >> B)` as a single operand.
- **Switch Item**: `switch(...)` returns a helper object. Its `__getitem__` receives:
    - A single `CaseNode` (if one case).
    - A `tuple` of `CaseNode`s (if multiple cases).
- **Dry Run Hooks**: Control-flow nodes implement `validate(ctx)` which run as part of `pyoco check --dry-run` to ensure expressions resolve and iterables are present.
- **Serialization**: AST nodes expose `.to_dict()` so dry-run and `pyoco check --dry-run --json` can emit machine-readable artifacts.

---

## 2. Debugging Features (Remote Observability)

Instead of complex interactive debugging (breakpoints, stepping), we focus on **Post-Mortem Observability** and **Remote Inspection**. This allows users to understand "what happened" and "why it failed" without needing to attach to a running process, which is essential for remote execution.

### 2.1 Enhanced State Tracking
- **Error Details**: `RunContext` (and Server Store) will store the full **stack trace** and **error message** for failed tasks.
- **Task Inputs/Outputs**: (Optional for MVP) Store task inputs and return values for inspection.
- **Retention Policy**: keep the last N runs (configurable, default 50) in memory with optional spill to disk (`artifacts/runs/<run_id>.json`).
- **Redaction**: allow tasks to mark fields as `sensitive` so they are omitted from persisted context.
- **Run Record Schema**
    - `run_id`, `flow_name`, `started_at`, `ended_at`, `status`.
    - `tasks`: per-task entry containing `state`, `started_at`, `ended_at`, `duration_ms`, `error`, `inputs`, `outputs`, `artifacts`.
    - `metadata`: user-supplied tags (team, purpose, etc.).
    - `config`: `cute_mode`, `env`, `params`.
- **API Surface**
    - Server exposes `/runs/<run_id>` (GET) returning the schema above.
    - `/runs` (GET) supports pagination/filter by status/time.

### 2.2 Remote Log Capture
- **Mechanism**: Workers capture `stdout` / `stderr` during task execution.
- **Transmission**: Logs are sent to the Kanban Server (chunked or at task end).
- **Storage**: Server keeps logs in-memory (or persistent store in future).
- **Format**: each chunk tagged with run_id, task_name, stream (`stdout`/`stderr`), sequence number, timestamp.
- **Backpressure**: if the server cannot accept logs, workers buffer up to 1 MB per task then truncate with a warning.
- **Chunk Schema**
    - `{ "run_id": str, "task": str, "stream": "stdout"|"stderr", "seq": int, "payload": str, "ts": iso8601 }`.
    - Workers must send a final `seq` with `eof=True` to indicate completion.
- **Security**
    - Server authenticates worker requests via shared token configured in both CLI and worker config.

### 2.3 CLI Inspection Tools

#### `pyoco runs inspect <run_id>`
Shows detailed status of a run, including:
- Task states and durations.
- **Full stack traces** for failed tasks.
- Input parameters.
- `--json` flag outputs machine-readable payload for tooling.
- Output layout:
    - Header with run metadata and elapsed time.
    - Table of tasks sorted by start time.
    - Collapsible sections (or CLI equivalent) for stack traces and captured inputs/outputs.

#### `pyoco runs logs <run_id>`
Fetches and displays the captured logs for a specific run (or task).
- `--task <name>`: Filter logs by task.
- `--tail <n>`: Show last N lines.
- `--follow` streams logs until completion when connected to a running worker.
- When following, CLI polls every 1s (configurable) and prints logs in `[ts][task][stream] line` format.
- Exits with non-zero status if run finishes with failure unless `--allow-failure` is passed.

### 2.4 "Dry Run" Validation
```bash
pyoco check --dry-run
```
- Simulates flow traversal to verify structure (loops, switches) without executing code.
- Useful for checking DSL correctness before submission.
- Emits structured warnings for potential issues:
    - Unbounded `UntilNode` without `max_iter`.
    - `switch` without default.
    - Iterables that resolve to empty sequences (info-level).
- Fails fast when expressions reference missing context keys.
- Exit codes:
    - `0` when structure is valid (even if warnings emitted).
    - `2` when validations fail (invalid expressions, missing keys, duplicates).
    - `3` for internal errors (traceback shown).
- `--json` flag returns `{ "status": "ok|warning|error", "warnings": [...], "errors": [...] }`.

## 3. Implementation Plan

1.  **DSL Parser/AST**: Implement the new nodes and operator overloading in `pyoco.dsl`.
2.  **Engine Support**: Update `Engine` to handle control flow nodes (loops, switches).
3.  **Debugging Tools**: Implement the agreed-upon debugging features.
