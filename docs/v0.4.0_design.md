# v0.4.0 Design: DSL Extensions & Debugging

## 1. DSL Extensions (Control Flow)

This section defines the new DSL syntax for loops and conditionals, prioritizing simplicity, clarity, and flow consistency.

### 1.1 Core Philosophy
- **Readability**: The meaning should be obvious at a glance.
- **Flow Consistency**: Maintain the left-to-right `>>` flow.
- **Symbolic Roles**:
    - `()`: Grouping
    - `[]`: Iteration (Count / For-each)
    - `%`: Conditional Loop (Until)
    - `switch()[...]`: Conditional Branching

### 1.2 Loop Extensions

#### 1.2.1 Interval Loop (Fixed Count)
```python
(B >> C)[3]
```
- Repeats the subflow `B >> C` 3 times.
- Expands to: `B >> C >> B >> C >> B >> C`

#### 1.2.2 For-Each Loop
```python
(B >> C)["$ctx.items"]
```
- Iterates over the list at `$ctx.items`.
- Executes `B >> C` for each element.
- The current item is injected into the context (e.g., as `item` or via a specific variable? *To be defined: how to access the current item inside the loop? Maybe `$ctx.item`?*)

#### 1.2.3 Conditional Loop (Until)
```python
(B >> C) % "$ctx.metrics.acc > 0.9"
```
- Repeats `B >> C` until the condition evaluates to True.
- Condition is checked *after* execution? Or before? *Standard `while` is before, `do-while` is after. The syntax `%` suggests "modulo" or "remainder", but here it's "repeat subject to condition". Let's assume standard "while" semantics or "until" semantics as specified.*
- User spec says: "Trueになるまで" (until True). So it repeats *while* False? Or stops when True.

### 1.3 Conditional Branching (Switch)

#### 1.3.1 Syntax
```python
switch("$ctx.status")[
    "X" >> B,
    "Y" >> C,
    "*" >> D, # Default
]
```

#### 1.3.2 Behavior
- Evaluates `$ctx.status`.
- Matches against keys `"X"`, `"Y"`.
- Executes the corresponding task/flow.
- If no match, executes `*` (default) if present, otherwise proceeds to next node.

### 1.4 Value Reference Rules
- Always use `$ctx.xxx` or `$env.xxx`.
- No arbitrary `eval`. Simple parsing or safe evaluation.

### 1.5 Implementation Requirements
- **AST Nodes**: `RepeatNode`, `ForEachNode`, `UntilNode`, `SwitchNode`, `CaseNode`.
- **Operator Overloading**:
    - `__rshift__` (`>>`)
    - `__getitem__` (`[]`)
    - `__mod__` (`%`)
- **Switch Implementation**: `switch(expr)` returns a builder that implements `__getitem__` to accept a tuple of cases.

---

### 1.6 Technical Implementation Details
- **String >> Task**: To support `"X" >> B`, the `Task` (and `Flow`) class must implement `__rrshift__`.
    - When Python sees `"X" >> B`, it tries `str.__rshift__`. Since that fails, it tries `B.__rrshift__("X")`.
    - We will implement `__rrshift__` to return a `CaseNode(value="X", target=B)`.
- **Switch Item**: `switch(...)` returns a helper object. Its `__getitem__` receives:
    - A single `CaseNode` (if one case).
    - A `tuple` of `CaseNode`s (if multiple cases).

---

## 2. Debugging Features (Remote Observability)

Instead of complex interactive debugging (breakpoints, stepping), we focus on **Post-Mortem Observability** and **Remote Inspection**. This allows users to understand "what happened" and "why it failed" without needing to attach to a running process, which is essential for remote execution.

### 2.1 Enhanced State Tracking
- **Error Details**: `RunContext` (and Server Store) will store the full **stack trace** and **error message** for failed tasks.
- **Task Inputs/Outputs**: (Optional for MVP) Store task inputs and return values for inspection.

### 2.2 Remote Log Capture
- **Mechanism**: Workers capture `stdout` / `stderr` during task execution.
- **Transmission**: Logs are sent to the Kanban Server (chunked or at task end).
- **Storage**: Server keeps logs in-memory (or persistent store in future).

### 2.3 CLI Inspection Tools

#### `pyoco runs inspect <run_id>`
Shows detailed status of a run, including:
- Task states and durations.
- **Full stack traces** for failed tasks.
- Input parameters.

#### `pyoco runs logs <run_id>`
Fetches and displays the captured logs for a specific run (or task).
- `--task <name>`: Filter logs by task.
- `--tail <n>`: Show last N lines.

### 2.4 "Dry Run" Validation
```bash
pyoco check --dry-run
```
- Simulates flow traversal to verify structure (loops, switches) without executing code.
- Useful for checking DSL correctness before submission.

## 3. Implementation Plan

1.  **DSL Parser/AST**: Implement the new nodes and operator overloading in `pyoco.dsl`.
2.  **Engine Support**: Update `Engine` to handle control flow nodes (loops, switches).
3.  **Debugging Tools**: Implement the agreed-upon debugging features.
